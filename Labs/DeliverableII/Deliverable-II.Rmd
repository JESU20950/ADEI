---
output:
  word_document:
    toc: no
    toc_depth: '4'
---
# Load Required Packages: to be increased over the course

```{r}
# Load Required Packages: to be increased over the course
options(contrasts=c("contr.treatment","contr.treatment"))

requiredPackages <- c("missMDA","chemometrics","mvoutlier","effects","FactoMineR","car", "factoextra","RColorBrewer","ggplot2","dplyr","ggmap","ggthemes","knitr","ggpubr")
missingPackages <- requiredPackages[!(requiredPackages %in% installed.packages()[,"Package"])]

if(length(missingPackages)) install.packages(missingPackages)
lapply(requiredPackages, require, character.only = TRUE)

```



## Load Processed data

```{r, echo=FALSE, results='FALSE'}
# Clear plots
if(!is.null(dev.list())) dev.off()

# Clean workspace
rm(list=ls())

#setwd("C:/Users/carle/Desktop/ADEI2")
#filepath<-"C:/Users/carle/Desktop/ADEI2/"


setwd("~/Desktop/ADEI/Labs/DeliverableII")
df <- read.table("Deliverable1.csv",header=T, sep=",");

```


# Principal Component Analysis

```{r}
vars_dis <- c("VendorID", "Payment_type", "Store_and_fwd_flag",  "RateCodeID", "f.Extra", "f.MTA_tax", "f.Improvement_surcharge", "lpep_pickup_period", "Trip_type", "lpep_pickup_date", "multiouts", "f.espeed", "f.tlenkm", "f.traveltime", "f.distHaversine", "AnyToll", "f.Fare_amount", "f.Passenger_count")

vars_con <- c( "Passenger_count", "tlenkm", "Pickup_longitude", "Pickup_latitude", "Dropoff_longitude", "Dropoff_latitude","Fare_amount", "espeed", "Tip_amount", "Tolls_amount", "lpep_pickup_time", "traveltime", "distHaversine")
for( i in vars_dis){
  df[,i] <- as.factor(df[,i])
}

vars_res <- c("AnyTip", "Total_amount")

d1 <- dim(df)[1]
d2 <- dim(df)[2]
df[,d2-1] <- as.factor(df[,d2-1])

#Todas las categoricas como suplementarias. Numericas suplementarias: Pickup_longitude, Pickup_latitude, Dropoff_longitude, Dropoff_latitude, total_amount
res.pca<-PCA(df[,c(1:10,19:(d2-2),d2)],quali.sup=c(1:10),quanti.sup=c(13:16,24), ncp=4, ind.sup = which(df$multiouts==TRUE)) 

# Multivariant outliers should be included as supplementary observations

plot.PCA(res.pca,choix=c("var"),invisible=c("quanti.sup"))
plot.PCA(res.pca,choix=c("var"),invisible=c("var"))
#plot.PCA(res.pca,choix=c("ind"))
plot.PCA(res.pca,choix=c("ind"),invisible=c("ind"))


plot.PCA(res.pca,choix=c("var"),invisible=c("quanti.sup"), axes=c(3,4))
plot.PCA(res.pca,choix=c("var"),invisible=c("var"), axes=c(3,4))
#plot.PCA(res.pca,choix=c("ind"), axes=c(3,4))
plot.PCA(res.pca,choix=c("ind"),invisible=c("ind"), axes=c(3,4))



### I. Eigenvalues and dominant axes. How many axes we have to interpret? ###
names(res.pca)

#summary(res.pca) # Customization is needed
summary(res.pca,nb.dec=2,nbind=1,nbelements=1000,ncp=4)


```

# Factoextra

```{r}
library(factoextra)
library(ggpubr)
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 50))
fviz_pca_var(res.pca, col.var = "steelblue")
library("corrplot")
#res.pca
corrplot(res.pca$var$coord, is.corr=FALSE)
corrplot(res.pca$var$cos2, is.corr=FALSE)

fviz_cos2(res.pca, choice = "var", axes = 1:2)
fviz_cos2(res.pca, choice = "ind", axes = 1:2)

# Color by cos2 values: quality on the factor map
fviz_pca_var(res.pca, col.var = "cos2", gradient.cols = c("white", "blue", "red"), repel = TRUE, legend.title="Nice plot") # Avoid text overlapping

# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 10)
fviz_contrib(res.pca, choice = "ind", axes = 1:2, top = 10)
res.desc <- dimdesc(res.pca, axes = c(1,2), proba = 0.05)
res.desc$Dim.1
```

## HCPC

```{r}
#res.hcpc<-HCPC(res.pca,order=TRUE)
res.hcpc<-HCPC(res.pca,nb.clust = -1,order=TRUE)
names(res.hcpc)
#res.hcpc<-HCPC(res.pca,min=8,max=12)
### Interpretar los resultados de la clasificación

################################
#Numero de individuos por cluster
barplot(table(res.hcpc$data.clust$clust))
#Descripcion de los clusters segun los ejes princiaples (ejes factoriales)
res.hcpc$desc.axes
#catdes(res.hcpc$data.clust,dim(res.hcpc$data.clust)[2]) # Jusificacion de la descripcion de los clusters segun las variables cualitativas.
#Descripcion de los clusters segun las variables cualitativas
res.hcpc$desc.var 
#Descripcion de los clusters segun los individuos 
res.hcpc$desc.ind 
#####################


### Interpretar los resultados de la clasificación


summary(res.hcpc$data.clust$clust)


### desc.var ###
### A. The description of the clusters by the variables ###
names(res.hcpc$desc.var)

### desc.var$test.chi2 ###
### A.1. The categorical variables which characterizes the clusters ###
res.hcpc$desc.var$test.chi2


### desc.var$category ###
### A.2. The description of each cluster by the categories ##
res.hcpc$desc.var$category
#Mod/Cluster Tanto porciento del cluster que forma parte de la modalidad.

### desc.var$quanti.var ###
### A.3. The quantitative variables which characterizes the clusters ###
res.hcpc$desc.var$quanti.var

### desc.var$quanti ###
### A.4. The description of each cluster by the quantitative variables ###
res.hcpc$desc.var$quanti

### desc.axes ###
### B. The description of the clusters by the axes ###
names(res.hcpc$desc.axes)
res.hcpc$desc.axes$quanti.var
res.hcpc$desc.axes$quanti

### desc.ind ###
### C. The description of the clusters by the individuals ###
names(res.hcpc$desc.ind)
res.hcpc$desc.ind$para
res.hcpc$desc.ind$dist

# Examinar los valores de los individuos que caracterizan a las clases
#### Characteristic individuals
para1<-which(rownames(res.pca$ind$coord)%in%names(res.hcpc$desc.ind$para[[1]]))
para2<-which(rownames(res.pca$ind$coord)%in%names(res.hcpc$desc.ind$para[[2]]))
para3<-which(rownames(res.pca$ind$coord)%in%names(res.hcpc$desc.ind$para[[3]]))
# to be completed...with as many clusters as you have selected

dist1<-which(rownames(res.pca$ind$coord)%in%names(res.hcpc$desc.ind$dist[[1]]))
dist2<-which(rownames(res.pca$ind$coord)%in%names(res.hcpc$desc.ind$dist[[2]]))
dist3<-which(rownames(res.pca$ind$coord)%in%names(res.hcpc$desc.ind$dist[[3]]))
# to be completed...with as many clusters as you have selected

plot(res.pca,label="none",invisible=c("quali","ind.sup"))  # Potser no us va
plot(res.pca$ind$coord[,1],res.pca$ind$coord[,2],col="grey80",cex=0.5,pch=16)
points(res.pca$ind$coord[para1,1],res.pca$ind$coord[para1,2],col="blue",cex=2,pch=16)
points(res.pca$ind$coord[dist1,1],res.pca$ind$coord[dist1,2],col="orange",cex=2,pch=16)
points(res.pca$ind$coord[para2,1],res.pca$ind$coord[para2,2],col="blue",cex=2,pch=16)
points(res.pca$ind$coord[dist2,1],res.pca$ind$coord[dist2,2],col="orange",cex=2,pch=16)
points(res.pca$ind$coord[para3,1],res.pca$ind$coord[para3,2],col="blue",cex=2,pch=16)
points(res.pca$ind$coord[dist3,1],res.pca$ind$coord[dist3,2],col="orange",cex=2,pch=16)
# to be completed...

res.hcpc$data.clust[which(rownames(res.hcpc$data.clust)%in%names(res.hcpc$desc.ind$para[[1]])),]
res.hcpc$data.clust[which(rownames(res.hcpc$data.clust)%in%names(res.hcpc$desc.ind$dist[[1]])),]
res.hcpc$data.clust[which(rownames(res.hcpc$data.clust)%in%names(res.hcpc$desc.ind$para[[2]])),]
res.hcpc$data.clust[which(rownames(res.hcpc$data.clust)%in%names(res.hcpc$desc.ind$dist[[2]])),]
# to be completed...
 
# Partition quality
#(res.hcpc$call$t$within[1]-res.hcpc$call$t$within['nb.clusters'])/res.hcpc$call$t$within[1]
(res.hcpc$call$t$within[1]-res.hcpc$call$t$within[6])/res.hcpc$call$t$within[1]
### Results for the hierarchical tree ###
names(res.hcpc$call$t)

### The suggested level to cut the tree  ###
res.hcpc$call$t$nb.clust
### Within inertias ###
res.hcpc$call$t$within[1:6]

### Ratio between within inertias ###
res.hcpc$call$t$quot[1:6]

### Inertia gain ###
res.hcpc$call$t$inert.gain[1:6]
df$hcpck<-res.hcpc$data.clust$clust

####
#### THE END
####
```

## Classification

```{r}

# Kmeans: Partitioning in k=7 groups
res.pca<-PCA(df[,c(1:10,19:(d2-2),d2)],quali.sup=c(1:10),quanti.sup=c(13:16,24), ncp=5, graph= FALSE) 
ppcc<-res.pca$ind$coord[,1:5]
dim(ppcc)

library("factoextra")
fviz_nbclust(ppcc, kmeans, method = "gap_stat")
library("NbClust") # It takes a lot ....
set.seed(123)
res.nbclust <- NbClust(ppcc, distance = "euclidean",
                  min.nc = 2, max.nc = 10, 
                  method = "complete", index ="all") # Time consuming

dist<-dist(ppcc)
kc<-kmeans(dist,6, iter.max = 30, trace=T)

df$claKM<-0
df[names(kc$cluster),"claKM"]<-kc$cluster
df$claKM<-factor(df$claKM)
kc$betweenss/kc$totss

names(df)
catdes(df,38)

# Confusion table

table(df$hcpck,df$claKM)

df$hcpck<-factor(df$hcpck,labels=paste("kHP-",1:6))
df$claKM<-factor(df$claKM,levels=c(3,6,2,1,5,4),labels=c("kKM-3","kKM-6","kKM-2","kKM-1","kKM-5","kKM-4"))
tt<-table(df$hcpck,df$claKM)
tt
sum(diag(tt)/sum(tt))
```


